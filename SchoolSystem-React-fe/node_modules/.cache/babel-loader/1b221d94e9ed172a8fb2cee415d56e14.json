{"ast":null,"code":"var _jsxFileName = \"/Users/mohamedmaqil/Desktop/SchoolSystem/SchoolSystem-React-fe/src/providers/Auth.tsx\",\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport React, { useEffect, useState, createContext, useContext } from \"react\";\nimport { Auth } from \"aws-amplify\";\nimport { getI18n } from \"react-i18next\";\nimport axios from \"axios\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AuthContext = /*#__PURE__*/createContext({\n  user: {},\n  loading: true,\n  signIn: (username, password) => {},\n  signOut: () => {},\n  getUserSession: () => {},\n  changePassword: (user, oldPassword, newPassword) => {},\n  completeNewPassword: (user, newPassword) => {},\n  forgotPassword: username => {},\n  // confirmSignIn: (user, mfaCode) => {},\n  // verifyTOTP: (user, totpCode) => {},\n  // updateUserAttributes: (user, attributes) => {},\n  // clearCognitoData: () => {},\n  forgotPasswordSubmit: (username, code, newPassword) => {} // userAttributeVerification: attribute => {},\n  // userAttributeVerificationSubmit: (attribute, code) => {},\n  // refreshSession: () => {},\n  // checkSessionExpired: () => {},\n  // getSubId: () => {}\n\n});\nexport const AuthProvider = props => {\n  _s();\n\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  useEffect(() => {\n    /**\n        Get the current user's information.\n        Should be used after the user is logged in. Returns an error if not signed in\n        @return response - the result of the API call. returns data: the authenticated user object\n    */\n    const getCurrentUser = async () => {\n      setLoading(true);\n\n      if (user) {\n        // currentUser already exisiting\n        setUser(user);\n        setLoading(false);\n      } else {\n        try {\n          let loggedUser = await Auth.currentAuthenticatedUser();\n          setUser(loggedUser); // currentUser checking aws\n        } catch (error) {\n          console.debug(\"ERROR: getCurrentUser \", error);\n        }\n\n        setLoading(false);\n      }\n    };\n\n    getCurrentUser();\n  }, [user]);\n  /*    COGNITO USER FUNCTIONS    */\n  // /**\n  //       Get user's current session. Refreshes accessToken and idToken if expired and a valid\n  //       refresh token is presented\n  //       @return response - the result of the API call.\n  //       returns a CognitoUserSession object which contains JWT, idToken, and refreshToken\n  //   */\n  // const getUserSession = async () => {\n  //   let response = {};\n  //   Auth.currentSession()\n  //     .then(data => {\n  //       response = {\n  //         data: data,\n  //         status: \"SUCCESS\"\n  //       };\n  //     })\n  //     .catch(error => {\n  //       console.debug(\"ERROR: occured while getting user session \", error);\n  //       response = {\n  //         error: error,\n  //         status: \"FAIL\"\n  //       };\n  //     });\n  //   return response;\n  // };\n  // /**\n  //       Update the user's attributes\n  //       @param attributes - object of user's attributes to be updated\n  //       @return response - the result from updating the attributes\n  //   */\n  // const updateUserAttributes = async (user, attributes: object) => {\n  //   let response = {};\n  //   await Auth.updateUserAttributes(user, attributes)\n  //     .then(result => {\n  //       response = {\n  //         data: result,\n  //         status: \"SUCCESS\"\n  //       };\n  //     })\n  //     .catch(error => {\n  //       console.debug(\"ERROR: occured updating the user's attributes \", error);\n  //       response = {\n  //         error: error,\n  //         status: \"FAIL\"\n  //       };\n  //     });\n  //   return response;\n  // };\n  // /**\n  //  * Clear all the current user's cognito data\n  //  */\n  // const clearCognitoData = () => {\n  //   setUser(null);\n  // };\n\n  /*  **********  COGNITO SIGN IN/OUT  **********  */\n\n  /**\n        Sign in and authenticate user.\n        First time users must enter a new password.\n        User's info is stored to avoid recalling the API\n        @return - Authenticated User's information - For TOTP returns code\n    */\n\n  const signIn = async (username, password) => {\n    let response;\n    setLoading(true); // Headers\n\n    const headers = {\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    };\n    axios.post(process.env.REACT_APP_HOST + \"/graphql\", {\n      query: `\n          mutation {\n            signin(email:\"` + username + `\", password:\"` + password + `\")\n           }\n          `\n    }, headers).then(res => {\n      console.log(\"res: \", res);\n\n      if (res.data.errors) {// dispatch(returnErrors(res.data.errors, \"LOGIN_FAIL\"));\n      } else {\n        console.log(\"res.data.data: \", res.data.data);\n        alert(\"success\"); // dispatch({ type: LOGIN_SUCCESS, payload: res.data.data });\n      }\n    }).catch(err => {\n      console.log(\"err: \", err); // dispatch(returnErrors(err, \"LOGIN_FAIL\"));\n      // dispatch({\n      // type: LOGIN_FAIL\n      // });\n    });\n    setLoading(false);\n    return response;\n  }; // /**\n  //  * Complete login for user after submitting MFA code\n  //  * @param user\n  //  * @param mfaCode\n  //  * @returns response - successful verification returns user object\n  //  */\n  // const confirmSignIn = async (user: any, mfaCode: string) => {\n  //   let response;\n  //   let loggedUser;\n  //   setLoading(true);\n  //   try {\n  //     if (user.challengeName === \"CUSTOM_CHALLENGE\") {\n  //       loggedUser = await Auth.sendCustomChallengeAnswer(\n  //         user, // Return object from Auth.signIn()\n  //         mfaCode // Confirmation code\n  //       );\n  //       // the answer was sent successfully, but it doesnt mean it is the right one\n  //       // so we should test if the user is authenticated now\n  //       // this will throw an error if the user is not yet authenticated:\n  //       await Auth.currentSession();\n  //     } else {\n  //       loggedUser = await Auth.confirmSignIn(\n  //         user, // Return object from Auth.signIn()\n  //         mfaCode // Confirmation code\n  //       );\n  //     }\n  //     setUser(loggedUser);\n  //     response = {\n  //       data: loggedUser,\n  //       status: \"SUCCESS\"\n  //     };\n  //   } catch (error: any) {\n  //     response = {\n  //       error: error,\n  //       status: \"FAIL\"\n  //     };\n  //   }\n  //   setLoading(false);\n  //   return response;\n  // };\n  // /**\n  //  * Verify One-time password from cognito\n  //  * @param user\n  //  * @param totpCode\n  //  * @return response - successful verification returns user object\n  //  */\n  // const verifyTOTP = async (user, totpCode: string) => {\n  //   let response;\n  //   Auth.verifyTotpToken(user, totpCode)\n  //     .then(user => {\n  //       // don't forget to set TOTP as the preferred MFA method\n  //       Auth.setPreferredMFA(user, \"TOTP\");\n  //       // ...\n  //       response = {\n  //         data: user,\n  //         status: \"SUCCESS\"\n  //       };\n  //     })\n  //     .catch(error => {\n  //       console.debug(\"ERROR: occured during verification\", error);\n  //       response = {\n  //         error: error,\n  //         status: \"FAIL\"\n  //       };\n  //     });\n  //   return response;\n  // };\n  // /**\n  //  * Sign user out of cognito\n  //  * @return response - a successful sign-out returns a \"SUCCESS\" status\n  //  */\n  // const signOut = async () => {\n  //   let response;\n  //   setLoading(true);\n  //   try {\n  //     let data = await Auth.signOut();\n  //     // User successfully signed out\n  //     clearCognitoData();\n  //     response = {\n  //       data: data,\n  //       status: \"SUCCESS\"\n  //     };\n  //     setLoading(false);\n  //   } catch (error: any) {\n  //     console.debug(\"ERROR: occured during sign out\", error);\n  //     response = {\n  //       error: error,\n  //       status: \"FAIL\"\n  //     };\n  //   }\n  //   return response;\n  // };\n  // /*  **********  COGNITO PASSWORD FUNCTIONS  **********  */\n  // /**\n  //  * Change user's password\n  //  * @param user\n  //  * @param oldPassword\n  //  * @param newPassword\n  //  * @return response - A successful request returns a promise\n  //  */\n  // const changePassword = async (\n  //   user: any,\n  //   oldPassword: string,\n  //   newPassword: string\n  // ) => {\n  //   let response;\n  //   try {\n  //     let data = await Auth.changePassword(user, oldPassword, newPassword);\n  //     response = {\n  //       data: data,\n  //       status: \"SUCCESS\"\n  //     };\n  //   } catch (error: any) {\n  //     response = {\n  //       error: error,\n  //       status: \"FAIL\"\n  //     };\n  //   }\n  //   return response;\n  // };\n  // /**\n  //  * Change a new user's password\n  //  * @param user\n  //  * @param newPassword\n  //  * @return response - A successful request returns a promise\n  //  */\n  // const completeNewPassword = async (user: any, newPassword: string) => {\n  //   let response;\n  //   setLoading(true);\n  //   try {\n  //     let data = await Auth.completeNewPassword(\n  //       user, // the Cognito User Object\n  //       newPassword // the new password\n  //     );\n  //     if (data.authenticationFlowType === \"CUSTOM_AUTH\") {\n  //       // custom auth complete password\n  //       setUser(data);\n  //     }\n  //     response = {\n  //       data: data,\n  //       status: \"SUCCESS\"\n  //     };\n  //   } catch (error: any) {\n  //     response = {\n  //       error: error,\n  //       status: \"FAIL\"\n  //     };\n  //   }\n  //   setLoading(false);\n  //   return response;\n  // };\n\n  /**\n   * Send user a link to reset the password\n   * @param username\n   * @return response - A successful request returns a promise\n   */\n\n\n  const forgotPassword = async username => {\n    let response;\n    setLoading(true);\n\n    try {\n      let data = await Auth.forgotPassword(username, {\n        language: getI18n().resolvedLanguage\n      });\n      response = {\n        data: data,\n        status: \"SUCCESS\"\n      };\n    } catch (error) {\n      console.debug(\"ERROR: unexpected error occured \", error);\n      response = {\n        error: error,\n        status: \"FAIL\"\n      };\n    }\n\n    setLoading(false);\n    return response;\n  };\n  /**\n   * Sumbit the verification code along with the user's new password\n   * @param username\n   * @param code - MFA code from cognito\n   * @param new_password\n   * @return response - A promise on success\n   */\n\n\n  const forgotPasswordSubmit = async (username, code, newPassword) => {\n    let response;\n    setLoading(true);\n\n    try {\n      let data = await Auth.forgotPasswordSubmit(username, code, newPassword);\n      response = {\n        data: data,\n        status: \"SUCCESS\"\n      };\n    } catch (error) {\n      console.debug(\"ERROR: occured submiting the verification code \", error);\n      response = {\n        error: error,\n        status: \"FAIL\"\n      };\n    }\n\n    setLoading(false);\n    return response;\n  }; // /**\n  //  * Send verification code to user's preffered method of communication\n  //  * @param attribute - user attribute to verify (email/sms)\n  //  * @return response - a promise data object on success\n  //  */\n  // const userAttributeVerification = async (attribute: string) => {\n  //   let response = {};\n  //   Auth.verifyCurrentUserAttribute(attribute)\n  //     .then(data => {\n  //       // verification code was sent to 'attribute'\n  //       response = {\n  //         data: data,\n  //         status: \"SUCCESS\"\n  //       };\n  //     })\n  //     .catch(error => {\n  //       console.debug(\"ERROR: occured verifying: \" + attribute + \" : \" + error);\n  //       response = {\n  //         error: error,\n  //         status: \"FAIL\"\n  //       };\n  //     });\n  //   return response;\n  // };\n  // /**\n  //  * Submit verification code for attribute\n  //  * @param attribute\n  //  * @param code\n  //  * @returns response - a promise data object on success\n  //  */\n  // const userAttributeVerificationSubmit = async (\n  //   attribute: string,\n  //   code: string\n  // ) => {\n  //   let response;\n  //   Auth.verifyCurrentUserAttributeSubmit(attribute, code)\n  //     .then(data => {\n  //       // 'attribute' verified\n  //       response = {\n  //         data: data,\n  //         status: \"SUCCESS\"\n  //       };\n  //     })\n  //     .catch(error => {\n  //       response = {\n  //         error: error,\n  //         status: \"FAIL\"\n  //       };\n  //     });\n  //   return response;\n  // };\n  // /**\n  //  * Submit verification code for attribute\n  //  * @returns response - a promise data object on success\n  //  */\n  // const refreshSession = async () => {\n  //   try {\n  //     const cognitoUser = await Auth.currentAuthenticatedUser();\n  //     const { refreshToken } = cognitoUser.getSignInUserSession();\n  //     cognitoUser.refreshSession(refreshToken, (err, session) => {\n  //       if (session) {\n  //         const { accessToken } = session;\n  //         let jwt = accessToken.getJwtToken();\n  //         let jwtObject = jwt_decode(jwt) as any;\n  //         let expireTime = jwtObject.exp as number;\n  //         sessionStorage.removeItem(\"alertMessage\");\n  //         sessionStorage.setItem(\"expiry\", String(expireTime));\n  //         // NEW EXPIRY TIME\n  //       }\n  //     });\n  //   } catch (e) {\n  //     console.debug(\"ERROR: unable to refresh Token\", e);\n  //   }\n  // };\n  // const checkSessionExpired = async () => {\n  //   let response = {};\n  //   try {\n  //     let currentTime = Math.floor(Date.now() / 1000);\n  //     let expiryTime = Number(sessionStorage.getItem(\"expiry\")) || null;\n  //     if (expiryTime && currentTime > expiryTime) {\n  //       // logout expired session\n  //       sessionStorage.removeItem(\"expiry\");\n  //       response = {\n  //         showAlert: true,\n  //         severity: \"error\",\n  //         message: \"all.alert.session-expired\"\n  //       };\n  //       sessionStorage.setItem(\"alertMessage\", JSON.stringify(response));\n  //       await signOut();\n  //     } else {\n  //       // refresh session\n  //       await refreshSession();\n  //     }\n  //   } catch (e) {\n  //     console.debug(\"ERROR: checkSessionExpired failed \", e);\n  //   }\n  //   return response;\n  // };\n  // /**\n  //  * Submit verification code for attribute\n  //  * @returns response - a promise data object on success\n  //  */\n  // const getSubId = async () => {\n  //   try {\n  //     const cognitoUser = await Auth.currentAuthenticatedUser();\n  //     const { idToken } = cognitoUser.getSignInUserSession();\n  //     return idToken.payload.sub;\n  //   } catch (e) {\n  //     console.debug(\"ERROR: unable to refresh Token\", e);\n  //   }\n  // };\n\n\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: {\n      user,\n      loading,\n      signIn,\n      // signOut,\n      // getUserSession,\n      // changePassword,\n      // completeNewPassword,\n      forgotPassword,\n      // confirmSignIn,\n      // verifyTOTP,\n      // updateUserAttributes,\n      // clearCognitoData,\n      forgotPasswordSubmit // userAttributeVerification,\n      // userAttributeVerificationSubmit,\n      // refreshSession,\n      // checkSessionExpired,\n      // getSubId\n\n    },\n    children: props.children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 511,\n    columnNumber: 5\n  }, this);\n};\n\n_s(AuthProvider, \"NiO5z6JIqzX62LS5UWDgIqbZYyY=\");\n\n_c = AuthProvider;\nexport const useAuth = () => {\n  _s2();\n\n  return useContext(AuthContext);\n};\n\n_s2(useAuth, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n\nvar _c;\n\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"sources":["/Users/mohamedmaqil/Desktop/SchoolSystem/SchoolSystem-React-fe/src/providers/Auth.tsx"],"names":["React","useEffect","useState","createContext","useContext","Auth","getI18n","axios","AuthContext","user","loading","signIn","username","password","signOut","getUserSession","changePassword","oldPassword","newPassword","completeNewPassword","forgotPassword","forgotPasswordSubmit","code","AuthProvider","props","setUser","setLoading","getCurrentUser","loggedUser","currentAuthenticatedUser","error","console","debug","response","headers","post","process","env","REACT_APP_HOST","query","then","res","log","data","errors","alert","catch","err","language","resolvedLanguage","status","children","useAuth"],"mappings":"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,IAAI;AACZhB,MAAAA,OAAO,CAACW,GAAR,CAAY,OAAZ,EAAqBK,GAArB,EADY,CAEZ;AACA;AACE;AACF;AACD,KA9BH;AA+BArB,IAAAA,UAAU,CAAC,KAAD,CAAV;AACA,WAAOO,QAAP;AACD,GA3CD,CAnGmC,CAgJnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACF;AACA;AACA;AACA;;;AACE,QAAMb,cAAc,GAAG,MAAOR,QAAP,IAA4B;AACjD,QAAIqB,QAAJ;AACAP,IAAAA,UAAU,CAAC,IAAD,CAAV;;AACA,QAAI;AACF,UAAIiB,IAAI,GAAG,MAAMtC,IAAI,CAACe,cAAL,CAAoBR,QAApB,EAA8B;AAC7CoC,QAAAA,QAAQ,EAAE1C,OAAO,GAAG2C;AADyB,OAA9B,CAAjB;AAGAhB,MAAAA,QAAQ,GAAG;AACTU,QAAAA,IAAI,EAAEA,IADG;AAETO,QAAAA,MAAM,EAAE;AAFC,OAAX;AAID,KARD,CAQE,OAAOpB,KAAP,EAAmB;AACnBC,MAAAA,OAAO,CAACC,KAAR,CAAc,kCAAd,EAAkDF,KAAlD;AACAG,MAAAA,QAAQ,GAAG;AACTH,QAAAA,KAAK,EAAEA,KADE;AAEToB,QAAAA,MAAM,EAAE;AAFC,OAAX;AAID;;AACDxB,IAAAA,UAAU,CAAC,KAAD,CAAV;AACA,WAAOO,QAAP;AACD,GApBD;AAsBA;AACF;AACA;AACA;AACA;AACA;AACA;;;AACE,QAAMZ,oBAAoB,GAAG,OAC3BT,QAD2B,EAE3BU,IAF2B,EAG3BJ,WAH2B,KAIxB;AACH,QAAIe,QAAJ;AACAP,IAAAA,UAAU,CAAC,IAAD,CAAV;;AACA,QAAI;AACF,UAAIiB,IAAI,GAAG,MAAMtC,IAAI,CAACgB,oBAAL,CAA0BT,QAA1B,EAAoCU,IAApC,EAA0CJ,WAA1C,CAAjB;AACAe,MAAAA,QAAQ,GAAG;AACTU,QAAAA,IAAI,EAAEA,IADG;AAETO,QAAAA,MAAM,EAAE;AAFC,OAAX;AAID,KAND,CAME,OAAOpB,KAAP,EAAmB;AACnBC,MAAAA,OAAO,CAACC,KAAR,CAAc,iDAAd,EAAiEF,KAAjE;AACAG,MAAAA,QAAQ,GAAG;AACTH,QAAAA,KAAK,EAAEA,KADE;AAEToB,QAAAA,MAAM,EAAE;AAFC,OAAX;AAID;;AACDxB,IAAAA,UAAU,CAAC,KAAD,CAAV;AACA,WAAOO,QAAP;AACD,GAtBD,CAnVmC,CA2WnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,sBACE,QAAC,WAAD,CAAa,QAAb;AACE,IAAA,KAAK,EAAE;AACLxB,MAAAA,IADK;AAELC,MAAAA,OAFK;AAGLC,MAAAA,MAHK;AAIL;AACA;AACA;AACA;AACAS,MAAAA,cARK;AASL;AACA;AACA;AACA;AACAC,MAAAA,oBAbK,CAcL;AACA;AACA;AACA;AACA;;AAlBK,KADT;AAAA,cAsBGG,KAAK,CAAC2B;AAtBT;AAAA;AAAA;AAAA;AAAA,UADF;AA0BD,CA1fM;;GAAM5B,Y;;KAAAA,Y;AA4fb,OAAO,MAAM6B,OAAO,GAAG,MAAM;AAAA;;AAC3B,SAAOhD,UAAU,CAACI,WAAD,CAAjB;AACD,CAFM;;IAAM4C,O","sourcesContent":["import React, { useEffect, useState, createContext, useContext } from \"react\";\nimport { Auth } from \"aws-amplify\";\nimport { CognitoUserInterface } from \"@aws-amplify/ui-components\";\nimport jwt_decode from \"jwt-decode\";\nimport { getI18n } from \"react-i18next\";\nimport axios from \"axios\";\n\nconst AuthContext = createContext({\n  user: {} as CognitoUserInterface | null,\n  loading: true as boolean | null,\n\n  signIn: (username, password) => {},\n  signOut: () => {},\n  getUserSession: () => {},\n  changePassword: (user, oldPassword, newPassword) => {},\n  completeNewPassword: (user, newPassword) => {},\n  forgotPassword: username => {},\n  // confirmSignIn: (user, mfaCode) => {},\n  // verifyTOTP: (user, totpCode) => {},\n  // updateUserAttributes: (user, attributes) => {},\n  // clearCognitoData: () => {},\n  forgotPasswordSubmit: (username, code, newPassword) => {},\n  // userAttributeVerification: attribute => {},\n  // userAttributeVerificationSubmit: (attribute, code) => {},\n  // refreshSession: () => {},\n  // checkSessionExpired: () => {},\n  // getSubId: () => {}\n});\n\nexport const AuthProvider = props => {\n  const [user, setUser] = useState<CognitoUserInterface | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    /**\n        Get the current user's information.\n        Should be used after the user is logged in. Returns an error if not signed in\n        @return response - the result of the API call. returns data: the authenticated user object\n    */\n    const getCurrentUser = async () => {\n      setLoading(true);\n      if (user) {\n        // currentUser already exisiting\n        setUser(user);\n        setLoading(false);\n      } else {\n        try {\n          let loggedUser = await Auth.currentAuthenticatedUser();\n          setUser(loggedUser);\n\n          // currentUser checking aws\n        } catch (error: any) {\n          console.debug(\"ERROR: getCurrentUser \", error);\n        }\n        setLoading(false);\n      }\n    };\n\n    getCurrentUser();\n\n  }, [user]);\n\n  /*    COGNITO USER FUNCTIONS    */\n\n  // /**\n  //       Get user's current session. Refreshes accessToken and idToken if expired and a valid\n  //       refresh token is presented\n  //       @return response - the result of the API call.\n  //       returns a CognitoUserSession object which contains JWT, idToken, and refreshToken\n  //   */\n  // const getUserSession = async () => {\n  //   let response = {};\n  //   Auth.currentSession()\n  //     .then(data => {\n  //       response = {\n  //         data: data,\n  //         status: \"SUCCESS\"\n  //       };\n  //     })\n  //     .catch(error => {\n  //       console.debug(\"ERROR: occured while getting user session \", error);\n  //       response = {\n  //         error: error,\n  //         status: \"FAIL\"\n  //       };\n  //     });\n  //   return response;\n  // };\n\n  // /**\n  //       Update the user's attributes\n  //       @param attributes - object of user's attributes to be updated\n  //       @return response - the result from updating the attributes\n  //   */\n  // const updateUserAttributes = async (user, attributes: object) => {\n  //   let response = {};\n  //   await Auth.updateUserAttributes(user, attributes)\n  //     .then(result => {\n  //       response = {\n  //         data: result,\n  //         status: \"SUCCESS\"\n  //       };\n  //     })\n  //     .catch(error => {\n  //       console.debug(\"ERROR: occured updating the user's attributes \", error);\n  //       response = {\n  //         error: error,\n  //         status: \"FAIL\"\n  //       };\n  //     });\n  //   return response;\n  // };\n\n  // /**\n  //  * Clear all the current user's cognito data\n  //  */\n  // const clearCognitoData = () => {\n  //   setUser(null);\n  // };\n\n  /*  **********  COGNITO SIGN IN/OUT  **********  */\n\n  /**\n        Sign in and authenticate user.\n        First time users must enter a new password.\n        User's info is stored to avoid recalling the API\n        @return - Authenticated User's information - For TOTP returns code\n    */\n  const signIn = async (username: string, password: string) => {\n    let response;\n    setLoading(true);\n    // Headers\n    const headers = {\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    };\n\n    axios.post( process.env.REACT_APP_HOST + \"/graphql\", \n      {\n        query:\n          `\n          mutation {\n            signin(email:\"` +\n            username +\n            `\", password:\"` +\n            password +\n            `\")\n           }\n          `\n      }, headers\n      ) \n      .then(res => {\n        console.log(\"res: \", res)\n        if (res.data.errors) {\n          // dispatch(returnErrors(res.data.errors, \"LOGIN_FAIL\"));\n        } else {\n          console.log(\"res.data.data: \", res.data.data);\n          alert(\"success\")\n          // dispatch({ type: LOGIN_SUCCESS, payload: res.data.data });\n        }\n      })\n      .catch(err => {\n        console.log(\"err: \", err)\n        // dispatch(returnErrors(err, \"LOGIN_FAIL\"));\n        // dispatch({\n          // type: LOGIN_FAIL\n        // });\n      });\n    setLoading(false);\n    return response;\n  };\n\n  // /**\n  //  * Complete login for user after submitting MFA code\n  //  * @param user\n  //  * @param mfaCode\n  //  * @returns response - successful verification returns user object\n  //  */\n  // const confirmSignIn = async (user: any, mfaCode: string) => {\n  //   let response;\n  //   let loggedUser;\n  //   setLoading(true);\n  //   try {\n  //     if (user.challengeName === \"CUSTOM_CHALLENGE\") {\n  //       loggedUser = await Auth.sendCustomChallengeAnswer(\n  //         user, // Return object from Auth.signIn()\n  //         mfaCode // Confirmation code\n  //       );\n  //       // the answer was sent successfully, but it doesnt mean it is the right one\n  //       // so we should test if the user is authenticated now\n  //       // this will throw an error if the user is not yet authenticated:\n  //       await Auth.currentSession();\n  //     } else {\n  //       loggedUser = await Auth.confirmSignIn(\n  //         user, // Return object from Auth.signIn()\n  //         mfaCode // Confirmation code\n  //       );\n  //     }\n\n  //     setUser(loggedUser);\n  //     response = {\n  //       data: loggedUser,\n  //       status: \"SUCCESS\"\n  //     };\n  //   } catch (error: any) {\n  //     response = {\n  //       error: error,\n  //       status: \"FAIL\"\n  //     };\n  //   }\n  //   setLoading(false);\n  //   return response;\n  // };\n\n\n  // /**\n  //  * Verify One-time password from cognito\n  //  * @param user\n  //  * @param totpCode\n  //  * @return response - successful verification returns user object\n  //  */\n  // const verifyTOTP = async (user, totpCode: string) => {\n  //   let response;\n  //   Auth.verifyTotpToken(user, totpCode)\n  //     .then(user => {\n  //       // don't forget to set TOTP as the preferred MFA method\n  //       Auth.setPreferredMFA(user, \"TOTP\");\n  //       // ...\n  //       response = {\n  //         data: user,\n  //         status: \"SUCCESS\"\n  //       };\n  //     })\n  //     .catch(error => {\n  //       console.debug(\"ERROR: occured during verification\", error);\n  //       response = {\n  //         error: error,\n  //         status: \"FAIL\"\n  //       };\n  //     });\n  //   return response;\n  // };\n\n  // /**\n  //  * Sign user out of cognito\n  //  * @return response - a successful sign-out returns a \"SUCCESS\" status\n  //  */\n  // const signOut = async () => {\n  //   let response;\n  //   setLoading(true);\n  //   try {\n  //     let data = await Auth.signOut();\n  //     // User successfully signed out\n  //     clearCognitoData();\n  //     response = {\n  //       data: data,\n  //       status: \"SUCCESS\"\n  //     };\n  //     setLoading(false);\n  //   } catch (error: any) {\n  //     console.debug(\"ERROR: occured during sign out\", error);\n  //     response = {\n  //       error: error,\n  //       status: \"FAIL\"\n  //     };\n  //   }\n  //   return response;\n  // };\n\n  // /*  **********  COGNITO PASSWORD FUNCTIONS  **********  */\n\n  // /**\n  //  * Change user's password\n  //  * @param user\n  //  * @param oldPassword\n  //  * @param newPassword\n  //  * @return response - A successful request returns a promise\n  //  */\n  // const changePassword = async (\n  //   user: any,\n  //   oldPassword: string,\n  //   newPassword: string\n  // ) => {\n  //   let response;\n  //   try {\n  //     let data = await Auth.changePassword(user, oldPassword, newPassword);\n  //     response = {\n  //       data: data,\n  //       status: \"SUCCESS\"\n  //     };\n  //   } catch (error: any) {\n  //     response = {\n  //       error: error,\n  //       status: \"FAIL\"\n  //     };\n  //   }\n  //   return response;\n  // };\n\n  // /**\n  //  * Change a new user's password\n  //  * @param user\n  //  * @param newPassword\n  //  * @return response - A successful request returns a promise\n  //  */\n  // const completeNewPassword = async (user: any, newPassword: string) => {\n  //   let response;\n  //   setLoading(true);\n  //   try {\n  //     let data = await Auth.completeNewPassword(\n  //       user, // the Cognito User Object\n  //       newPassword // the new password\n  //     );\n\n  //     if (data.authenticationFlowType === \"CUSTOM_AUTH\") {\n  //       // custom auth complete password\n  //       setUser(data);\n  //     }\n\n  //     response = {\n  //       data: data,\n  //       status: \"SUCCESS\"\n  //     };\n  //   } catch (error: any) {\n  //     response = {\n  //       error: error,\n  //       status: \"FAIL\"\n  //     };\n  //   }\n  //   setLoading(false);\n  //   return response;\n  // };\n\n  /**\n   * Send user a link to reset the password\n   * @param username\n   * @return response - A successful request returns a promise\n   */\n  const forgotPassword = async (username: string) => {\n    let response;\n    setLoading(true);\n    try {\n      let data = await Auth.forgotPassword(username, {\n        language: getI18n().resolvedLanguage\n      });\n      response = {\n        data: data,\n        status: \"SUCCESS\"\n      };\n    } catch (error: any) {\n      console.debug(\"ERROR: unexpected error occured \", error);\n      response = {\n        error: error,\n        status: \"FAIL\"\n      };\n    }\n    setLoading(false);\n    return response;\n  };\n\n  /**\n   * Sumbit the verification code along with the user's new password\n   * @param username\n   * @param code - MFA code from cognito\n   * @param new_password\n   * @return response - A promise on success\n   */\n  const forgotPasswordSubmit = async (\n    username: string,\n    code: string,\n    newPassword: string\n  ) => {\n    let response;\n    setLoading(true);\n    try {\n      let data = await Auth.forgotPasswordSubmit(username, code, newPassword);\n      response = {\n        data: data,\n        status: \"SUCCESS\"\n      };\n    } catch (error: any) {\n      console.debug(\"ERROR: occured submiting the verification code \", error);\n      response = {\n        error: error,\n        status: \"FAIL\"\n      };\n    }\n    setLoading(false);\n    return response;\n  };\n\n  // /**\n  //  * Send verification code to user's preffered method of communication\n  //  * @param attribute - user attribute to verify (email/sms)\n  //  * @return response - a promise data object on success\n  //  */\n  // const userAttributeVerification = async (attribute: string) => {\n  //   let response = {};\n  //   Auth.verifyCurrentUserAttribute(attribute)\n  //     .then(data => {\n  //       // verification code was sent to 'attribute'\n  //       response = {\n  //         data: data,\n  //         status: \"SUCCESS\"\n  //       };\n  //     })\n  //     .catch(error => {\n  //       console.debug(\"ERROR: occured verifying: \" + attribute + \" : \" + error);\n  //       response = {\n  //         error: error,\n  //         status: \"FAIL\"\n  //       };\n  //     });\n  //   return response;\n  // };\n\n  // /**\n  //  * Submit verification code for attribute\n  //  * @param attribute\n  //  * @param code\n  //  * @returns response - a promise data object on success\n  //  */\n  // const userAttributeVerificationSubmit = async (\n  //   attribute: string,\n  //   code: string\n  // ) => {\n  //   let response;\n  //   Auth.verifyCurrentUserAttributeSubmit(attribute, code)\n  //     .then(data => {\n  //       // 'attribute' verified\n  //       response = {\n  //         data: data,\n  //         status: \"SUCCESS\"\n  //       };\n  //     })\n  //     .catch(error => {\n  //       response = {\n  //         error: error,\n  //         status: \"FAIL\"\n  //       };\n  //     });\n  //   return response;\n  // };\n\n  // /**\n  //  * Submit verification code for attribute\n  //  * @returns response - a promise data object on success\n  //  */\n  // const refreshSession = async () => {\n  //   try {\n  //     const cognitoUser = await Auth.currentAuthenticatedUser();\n  //     const { refreshToken } = cognitoUser.getSignInUserSession();\n  //     cognitoUser.refreshSession(refreshToken, (err, session) => {\n  //       if (session) {\n  //         const { accessToken } = session;\n  //         let jwt = accessToken.getJwtToken();\n  //         let jwtObject = jwt_decode(jwt) as any;\n  //         let expireTime = jwtObject.exp as number;\n  //         sessionStorage.removeItem(\"alertMessage\");\n  //         sessionStorage.setItem(\"expiry\", String(expireTime));\n  //         // NEW EXPIRY TIME\n  //       }\n  //     });\n  //   } catch (e) {\n  //     console.debug(\"ERROR: unable to refresh Token\", e);\n  //   }\n  // };\n\n  // const checkSessionExpired = async () => {\n  //   let response = {};\n  //   try {\n  //     let currentTime = Math.floor(Date.now() / 1000);\n  //     let expiryTime = Number(sessionStorage.getItem(\"expiry\")) || null;\n  //     if (expiryTime && currentTime > expiryTime) {\n  //       // logout expired session\n  //       sessionStorage.removeItem(\"expiry\");\n\n  //       response = {\n  //         showAlert: true,\n  //         severity: \"error\",\n  //         message: \"all.alert.session-expired\"\n  //       };\n  //       sessionStorage.setItem(\"alertMessage\", JSON.stringify(response));\n  //       await signOut();\n  //     } else {\n  //       // refresh session\n  //       await refreshSession();\n  //     }\n  //   } catch (e) {\n  //     console.debug(\"ERROR: checkSessionExpired failed \", e);\n  //   }\n  //   return response;\n  // };\n\n  // /**\n  //  * Submit verification code for attribute\n  //  * @returns response - a promise data object on success\n  //  */\n  // const getSubId = async () => {\n  //   try {\n  //     const cognitoUser = await Auth.currentAuthenticatedUser();\n  //     const { idToken } = cognitoUser.getSignInUserSession();\n  //     return idToken.payload.sub;\n  //   } catch (e) {\n  //     console.debug(\"ERROR: unable to refresh Token\", e);\n  //   }\n  // };\n\n  return (\n    <AuthContext.Provider\n      value={{\n        user,\n        loading,\n        signIn,\n        // signOut,\n        // getUserSession,\n        // changePassword,\n        // completeNewPassword,\n        forgotPassword,\n        // confirmSignIn,\n        // verifyTOTP,\n        // updateUserAttributes,\n        // clearCognitoData,\n        forgotPasswordSubmit,\n        // userAttributeVerification,\n        // userAttributeVerificationSubmit,\n        // refreshSession,\n        // checkSessionExpired,\n        // getSubId\n      }}\n    >\n      {props.children}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = () => {\n  return useContext(AuthContext);\n};\n"]},"metadata":{},"sourceType":"module"}